package vm

import (
	"bufio"
	"fmt"
	"log"
	"log/slog"
	"os"
	"strings"
	"time"

	"kvmgo/utils"
)

func LaunchKubeWorkerNode(worker_name, master_name string) (*VMConfig, error) {
	StageWorkerArtifacts(master_name)

	config := NewVMConfig(worker_name).
		SetImageURL("https://cloud-images.ubuntu.com/releases/jammy/release/ubuntu-22.04-server-cloudimg-amd64.img").
		SetImagesDir("data/images").
		SetBootFilesDir("data/scripts/worker_kube").
		DefaultUserData().
		SetCores(2).
		SetMemory(2048).
		SetBootServices([]string{"kubeworker.service"})

	config.PullImage()

	utils.LogSection("CREATING BASE IMAGE")

	if err := config.CreateBaseImage(); err != nil {
		utils.LogError(fmt.Sprintf("Failed to Setup VM ERROR:%s", err))
		Cleanup(config.VMName)
		return nil, err
	}
	log.Printf("Modified Base Image Creation Success at %s", config.ImagesDir)

	utils.LogSection("SETTING UP VM")

	if err := config.SetupVM(); err != nil {
		utils.LogError(fmt.Sprintf("Failed to Setup VM ERROR:%s", err))
		Cleanup(config.VMName)
		return nil, err

	}

	utils.LogSection("GENERATING CLOUDINIT USERDATA")

	if err := config.GenerateCustomUserDataImg(); err != nil {
		utils.LogError(fmt.Sprintf("Failed to Generate Cloud-Init Disk ERROR:%s", err))
		Cleanup(config.VMName)
		return nil, err

	}

	log.Printf("Successfully Created Cloud-Init user-data .img file: %s", config.UserData)

	utils.LogSection("LAUNCHING VM")

	if err := config.CreateVM(); err != nil {
		utils.LogError(fmt.Sprintf("Failed to Create VM ERROR:%s", err))
		return nil, err

	}

	utils.IsVMRunning(config.VMName)

	slog.Info("VM created successfully")

	log.Printf("Run virsh console %s and sudo journalctl -u kubeworker to check boot logs for systemd of -fu to tail logs.", config.VMName)

	return config, nil
}

/*
StageWorkerArtifacts : Stages artifacts to join a Cluster

# Kubernetes Worker Nodes need to run the kubeadm join command generated by a Control Node

Usage:

	masterVM := "kubecontrol"

	if err := StageWorkerArtifacts(masterVM); err != nil {
		log.Printf("Error staging worker artifacts: %v", err)
		os.Exit(1)
	}
*/
func StageWorkerArtifacts(masterVM string) error {
	workerScriptPath := "data/scripts/worker_kube/launch_worker.sh"

	joinCommand, err := ExtractJoinCommand(masterVM)
	if err != nil {
		log.Printf("Error extracting join command: %v", err)
		return err
	}
	log.Printf("Extracted join command: %s", joinCommand)

	content, err := os.ReadFile(workerScriptPath)
	if err != nil {
		log.Printf("Failed to read worker script: %v", err)
		return err
	}

	scriptLines := strings.Split(string(content), "\n")
	var updatedScript strings.Builder
	var joinCommandAdded bool

	for _, line := range scriptLines {
		if strings.Contains(line, "Join Command not staged on Worker Script") || strings.Contains(line, "Joining worker node to Kubernetes Cluster initiated by") {
			updatedScript.WriteString(fmt.Sprintf("echo -e \"${BLUE}*** Joining worker node to Kubernetes Cluster initiated by %s ***${NC}\"\n", masterVM))
			// updatedScript.WriteString(joinCommand + "\n")
			updatedScript.WriteString(fmt.Sprintf("sudo %s\n\n", joinCommand))
			updatedScript.WriteString(fmt.Sprintf("# MASTER_VM: %s\n# TIMESTAMP: %s\n", masterVM, time.Now().Format(time.RFC3339)))
			joinCommandAdded = true
			break
		}

		if !joinCommandAdded {
			updatedScript.WriteString(line + "\n")
		}
	}

	if !joinCommandAdded {
		// In case placeholder or existing join command was not found, append at the end
		updatedScript.WriteString(fmt.Sprintf("echo -e \"${BLUE}*** Joining worker node to Kubernetes Cluster initiated by %s ***${NC}\"\n", masterVM))
		// updatedScript.WriteString(joinCommand + "\n")
		updatedScript.WriteString(fmt.Sprintf("sudo %s", joinCommand))

		updatedScript.WriteString(fmt.Sprintf("# MASTER_VM: %s\n# TIMESTAMP: %s\n", masterVM, time.Now().Format(time.RFC3339)))
	}

	err = os.WriteFile(workerScriptPath, []byte(updatedScript.String()), 0o644)
	if err != nil {
		log.Printf("Failed to write updated worker script: %v", err)
		return err
	}

	log.Printf("Worker script successfully updated with join command from '%s'", masterVM)
	return nil
}

func ExtractJoinCommand(masterVM string) (string, error) {
	kubeadmLogPath := fmt.Sprintf("data/artifacts/%s/kubeadm-init.log", masterVM)
	file, err := os.Open(kubeadmLogPath)
	if err != nil {
		log.Printf("Error opening kubeadm init log: %v", err)
		return "", fmt.Errorf("failed to open kubeadm init log: %v", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	var joinCommand strings.Builder
	foundJoin := false

	for scanner.Scan() {
		line := scanner.Text()

		// Check if we are currently reading the join command
		if foundJoin {
			line = strings.TrimSpace(line) // Remove leading/trailing spaces
			if strings.HasSuffix(line, "\\") {
				joinCommand.WriteString(" " + strings.TrimSuffix(line, "\\"))
			} else {
				joinCommand.WriteString(" " + line)
				break
			}
		}

		// Check for the start of the join command
		if strings.HasPrefix(line, "kubeadm join") {
			joinCommand.WriteString(strings.TrimSuffix(line, "\\"))
			if strings.HasSuffix(line, "\\") {
				foundJoin = true
			} else {
				break
			}
		}
	}

	if joinCommand.Len() == 0 {
		log.Printf("Join command not found in kubeadm init log")
		return "", fmt.Errorf("join command not found in kubeadm init log")
	}

	finalCommand := joinCommand.String()
	log.Printf("Final extracted join command: %s", finalCommand)
	return finalCommand, nil
}

func FindCurrentJoinCommand(workerScriptPath string) (string, error) {
	content, err := os.ReadFile(workerScriptPath)
	if err != nil {
		return "", fmt.Errorf("failed to read worker script: %v", err)
	}

	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "kubeadm join") {
			return line, nil
		}
	}
	return "", nil // No existing join command found
}

func FindPlaceholderLine(workerScriptPath string) (bool, error) {
	content, err := os.ReadFile(workerScriptPath)
	if err != nil {
		return false, fmt.Errorf("failed to read worker script: %v", err)
	}

	placeholder := "echo -e \"${RED}Join Command not staged on Worker Script${NC}\""
	return strings.Contains(string(content), placeholder), nil
}
